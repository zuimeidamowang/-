# `React18`新特性

## 1 自动批处理以减少渲染

批处理是 React将多个状态更新分组到单个重新渲染中以获得更好的性能。

例如，如果你在同一个点击事件中有两个状态更新，React 总是将它们分批处理到一个重新渲染中。如果你运行下面的代码，你会看到每次点击时，React 只执行一次渲染，尽管你设置了两次状态

这对性能非常有用，因为它避免了不必要的重新渲染。它还可以防止你的组件呈现仅更新一个状态变量的“半完成”状态，这可能会导致错误。

但是在React 18以前只会对同步任务进行批处理，默认情况下，React 中不会对 promise、setTimeout、本机事件处理程序或任何其他事件中的更新进行批处理。

从 React 18 开始createRoot，所有更新都将自动批处理，无论它们来自何处。

这意味着超时、承诺、本机事件处理程序或任何其他事件内的更新将以与 React 事件内的更新相同的方式进行批处理。

## 2 Suspense 的 SSR 支持

这基本上是服务器端渲染 (SSR) 逻辑的扩展。在典型的 React SSR 应用程序中，会发生以下步骤：

- 服务器获取需要在 UI 上显示的相关数据
- 服务器将整个应用程序呈现为 HTML 并将其发送给客户端作为响应
- 客户端下载 [JavaScript](https://cloud.tencent.com/product/sms?from=10680) 包（除了 HTML）
- 在最后一步，客户端将 javascript 逻辑连接到 HTML（称为 hydration）

典型 SSR 应用程序的问题在于，在下一步可以开始之前，必须立即完成整个应用程序的每个步骤。这会使您的应用程序在初始加载时变慢且无响应。

React 18 正试图解决这个问题。<Suspense> 组件已经以这样的方式进行了革命性的改变，它将应用程序分解为更小的独立单元，这些单元经过提到的每个步骤。这样一旦用户看到内容，它就会变成互动的。

## 3 startTransition

我们将状态更新分为两类：

- 紧急更新反应直接交互，如打字、悬停、拖动等。
- 过渡更新将 UI 从一个视图过渡到另一个视图。

单击、悬停、滚动或打字等紧急更新需要立即响应以匹配我们对物理对象行为方式的直觉。否则他们会觉得“错了”。

然而，转换是不同的，因为用户不希望在屏幕上看到每个中间值。

例如，当您在下拉列表中选择过滤器时，您希望过滤器按钮本身在您单击时立即响应。但是，实际结果可能会单独转换。

一个小的延迟是难以察觉的，而且通常是预料之中的。如果在结果渲染完成之前再次更改过滤器，您只关心看到最新的结果。

在典型的 React 应用程序中，大多数更新在概念上都是过渡更新。但出于向后兼容性的原因，过渡是可选的。

默认情况下，React 18 仍然将更新处理为紧急更新，您可以通过将更新包装到startTransition.

**在 React 18 之前，所有更新都被紧急渲染。**

这意味着上面的两个状态仍然会同时呈现，并且仍然会阻止用户看到他们交互的反馈，直到一切都呈现出来。我们缺少的是一种告诉 React 哪些更新是紧急的，哪些不是的方法。

新startTransitionAPI 通过让您能够将更新标记为“转换”来解决此问题：

```javascript
import  {  startTransition  }  from  'react' ;

// 紧急：显示输入的内容
setInputValue ( input ) ;

// 将内部的任何状态更新标记为转换
startTransition ( ( )  =>  { 
  // Transition: 显示结果
  setSearchQuery ( input ) ; 
} ) ;
```

包装在其中的更新startTransition被视为非紧急处理，如果出现更紧急的更新（如点击或按键），则会中断。

如果用户中断转换（例如，连续输入多个字符），React 将抛出未完成的陈旧渲染工作，仅渲染最新更新。

Transitions 可让您保持大多数交互敏捷，即使它们导致显着的 UI 更改。它们还可以让您避免浪费时间渲染不再相关的内容。

### **我可以在哪里使用它？**

您可以使用startTransition来包装要移动到后台的任何更新。通常，这些类型的更新分为两类：

- 缓慢渲染：这些更新需要时间，因为 React 需要执行大量工作才能转换 UI 以显示结果。
- 慢速网络：这些更新需要时间，因为 React 正在等待来自网络的一些数据。此用例与 Suspense 紧密集成。
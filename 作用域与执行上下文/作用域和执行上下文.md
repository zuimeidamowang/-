# 作用域和执行上下文

## 1 作用域

`JavaScript` 采用的是词法作用域：函数的作用域在函数定义的时候就确定了。

与词法作用域相对的是动态作用域：函数的作用域在函数被调用的时候才决定的。

作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

### 1.1 全局作用域

在整个程序生命周期内都是有效的，在任意的函数内部都能访问的变量或函数拥有全局作用域。

1. 定义在最外层的变量和函数，拥有全局作用域。

2. 未声明直接赋值的变量，拥有全局作用域。

3. 在浏览器环境中，定义在`window`对象上的属性，具有全局作用域。

### 1.2 函数作用域

在某个函数内部声明的变量或函数拥有函数作用域。它们只能被该函数的语句使用，函数外部是不可访问的。函数在创建的时候，变量和函数的函数作用域已经确定下来。函数的参数也属于函数内部的变量，因此拥有函数作用域。

当然可以利用闭包来实现跨区域访问局部作用域的变量;

### 1.3 块作用域

`ES6`新增了块级作用域，通过`const`和`let`关键字定义块级作用域。

`if`语句和`for`语句里面的{ }也属于块作用域。

`var`定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。

+ `let`声明的变量拥有块级作用域，`var`声明的变量没有块级作用域。

+ `var`命令会发生"变量提升"现象，即无论`var`声明的变量处于作用域的第几行，都会提升到作用域的头部，并初始化为`undefined`。而let命令声明的变量一定要在声明后使用，否则报错。

+ 只要块级作用域内存在`let`命令，它所声明的变量就"绑定"这个区域，凡是在声明之前就使用这些变量，就会报错。

+ `let`不允许在相同作用域内，重复声明同一个变量。

### 1.4 作用域链

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法搜索到某个变量时，引擎就会在外层嵌套的作用域中继续搜索，直到搜索到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这样一条有序的列表，称为作用域链，作用域链的最前端一定是当前作用域。

## 2 执行上下文

- `JavaScript`执行在单线程上，所有的代码都是排队执行。
- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的JS执行引擎总是访问栈顶的执行上下文。
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。
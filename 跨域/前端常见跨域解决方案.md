# 前端常见跨域解决方案

### **什么是跨域？**

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。

广义的跨域：

```xml
1.) 资源跳转： A链接、重定向、表单提交
2.) 资源嵌入： <link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件外链
3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
```

其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。

**什么是同源策略？**
同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

同源策略限制以下几种行为：

```mipsasm
1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
```

### **常见跨域场景**

```awk
URL                                      说明                    是否允许通信
http://www.domain.com/a.js
http://www.domain.com/b.js         同一域名，不同文件或路径           允许
http://www.domain.com/lab/c.js

http://www.domain.com:8000/a.js
http://www.domain.com/b.js         同一域名，不同端口                不允许
 
http://www.domain.com/a.js
https://www.domain.com/b.js        同一域名，不同协议                不允许
 
http://www.domain.com/a.js
http://192.168.4.12/b.js           域名和域名对应相同ip              不允许
 
http://www.domain.com/a.js
http://x.domain.com/b.js           主域相同，子域不同                不允许
http://domain.com/c.js
 
http://www.domain1.com/a.js
http://www.domain2.com/b.js        不同域名                         不允许
```

### **跨域解决方案**

1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

#### **一、 通过jsonp跨域**

通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

原生实现：

```xml
 <script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

服务端返回如下（返回时即执行全局函数）：

```javascript
handleCallback({"status": true, "user": "admin"})
```

jsonp缺点：只能实现get一种请求。

#### **二、 document.domain + iframe跨域**

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

1.）父窗口：([http://www.domain.com/a.html)](https://link.segmentfault.com/?enc=KKvhk0WkzLlJv1LV6SxKcA%3D%3D.wzFJ%2BXIDLiy%2FU9krzxu3fY1SiPFILky2yudOrAf7oc0%3D)

```xml
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

2.）子窗口：([http://child.domain.com/b.html)](https://link.segmentfault.com/?enc=MIMJALmHPaNj1QxfsHAZvA%3D%3D.pNMG9UHTBiDY%2BV%2BKPGrCQb9Fauf7tmxbmKCdcK6JdwM%3D)

```xml
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

不同域的网页可以彼此引用不同的网页内容，但是不能操作js。当两个网页的**当前域名或者基础域名相同**的时候，便可以互相操作js，所以我们可以使用**document.domain=" " 来显示指定便可以操作js.**

***利用document.domain 实现跨域：***

**该属性是一个只读的字符串，包含了载入当前文档的 web 服务器的主机名。**

**前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域.**

注释：a.yy.com  与 b.yy.com  此时yy.com是基础域名，a.yy.com与b.yy.com是当前的域名。若要两个实现跨域，需要指定document.domain="yy.com";

#### **三、 location.hash + iframe跨域**

实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

1.）a.html：([http://www.domain1.com/a.html)](https://link.segmentfault.com/?enc=FzJB3xpGHbP9%2BBjGQQHXyw%3D%3D.%2FiqlH%2BDh54WwZ5iutuSpbFS%2B3xYpSzNm1tsIZdl7mi0%3D)

```xml
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
```

2.）b.html：([http://www.domain2.com/b.html)](https://link.segmentfault.com/?enc=mqnDqtIHZXdUgvoaCYVISw%3D%3D.O4eXLGQjIMrEBg%2F6ix7hGtETBbG8d5smShdJwkFk8z8%3D)

```xml
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
```

3.）c.html：([http://www.domain1.com/c.html)](https://link.segmentfault.com/?enc=frShCW3Pdr2ctm6Br6MXlw%3D%3D.eW8Aj%2FurWfomAwHh40DKwxPYC65J00TDyLV%2Fq%2B5oye8%3D)

```xml
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。

返回一个 URL 的主要部分。假设当前的 URL 是 http://www.runoob.com/test.htm＃PART2：

```javascript
 document.write(location.hash);
```

以上实例输出结果：

`#part2`

#### **四、 window.name + iframe跨域**

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

1.）a.html：([http://www.domain1.com/a.html)](https://link.segmentfault.com/?enc=lvcvUf9grK5SNeTgOtpcug%3D%3D.eDHr5BsEC3aNGxYOkTq0vt0mp1RYvUtuNqlfa4CgzkU%3D)

```javascript
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};

// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});
```

2.）proxy.html：([http://www.domain1.com/proxy....](https://link.segmentfault.com/?enc=H3qgHV9LuqLfI4gcghtBUA%3D%3D.wRr1ERLopwa07snh%2Bn5oKTXwS%2B2uQn7aXNmRZgZLNv5PCika4%2FmmBbfz%2BGf9gf5I)
中间代理页，与a.html同域，内容为空即可。

3.）b.html：([http://www.domain2.com/b.html)](https://link.segmentfault.com/?enc=mrHH%2BIZIft0VuIAr%2F076Dg%3D%3D.BQlX5H28moO1IQj9AUgIpPcxGiIcIxX21oMMMUauytI%3D)

```xml
<script>
    window.name = 'This is domain2 data!';
</script>
```

总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

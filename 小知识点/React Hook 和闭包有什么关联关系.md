# `React Hook` 和闭包有什么关联关系

首先闭包是由函数以及创建该函数的词法环境组合而成。这个词法环境包含了该闭包创建时所能访问的所有局部变量。划重点是闭包创建时的变量值，闭包创建之后即使这些变量值改变了也不会影响到闭包内保存的这个变量。

而`useEffect`、`useMemo`、`useCallback`都是自带闭包的。每一次组件的渲染，它们都会捕获当前组件函数上下文中的状态`(state, props)`，所以每一次这三种`hooks`的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。

对 `Hook` 过时闭包的解决办法：

- 添加依赖项

注意依赖项为空和不传依赖项是两个概念，前者是传了依赖项但它是一个空数组，后者是直接不传这个参数。前者只有依赖项改变时才会执行函数，后者只要组件数据改变了就执行。

- 以函数的形式更新`state`

以函数的形式更新`state`，同 `react` 的 `setState` 一样，`useState Hook` 也可以通过函数的形式来修改 `state`，并且使用当前的` state `值作为函数参数。

- 使用`useRef`

通过 `useRef` 生成的对象来绑定` state`，这样更新 `state` 的时候就可以不用依赖于该 state，而是直接在该绑定对象上的基础上更新即可。

- 使用`useReducer`

`useReducer` 可以达到和使用函数形式更新的 `useState` 一样的效果，也是在更新时在当前的 `state` 基础上进行操作。